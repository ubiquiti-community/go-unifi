{{- $structName := .StructName }}

{{ define "field" }}
	{{ .FieldName }} {{ if .IsArray }}[]{{end}}{{ if and (.OmitEmpty) (.IsPointer) }}*{{ end }}{{ .FieldType }} `json:"{{ .JSONName }}{{ if .OmitEmpty }},omitempty{{ end }}"` {{ if .FieldValidation }}// {{ .FieldValidation }}{{ end }} {{- end }}
{{ define "field-customUnmarshalType" }}
	{{- if eq .CustomUnmarshalType "" }}{{else}}
			{{ .FieldName }} {{ if .IsArray }}[]{{end}}{{ .CustomUnmarshalType }} `json:"{{ .JSONName }}"`{{ end }} {{- end }}
{{ define "typecast" }}
	{{- if ne .CustomUnmarshalFunc "" }}
		dst.{{ .FieldName }}= {{ .CustomUnmarshalFunc }}(aux.{{ .FieldName }})
	{{- else if eq .CustomUnmarshalType "" }}{{else}}
		{{- if eq .CustomUnmarshalType "types.Number" }}
			{{- if .IsArray }}
	dst.{{ .FieldName }} = make([]{{ .FieldType }}, len(aux.{{ .FieldName }}))
	for i, v := range aux.{{ .FieldName }} {
		if val, err := v.Int64(); err == nil {
			dst.{{ .FieldName }}[i] = {{ .FieldType }}(val)
		}
	}
			{{- else }}
	if val, err := aux.{{ .FieldName }}.Int64(); err == nil {
		dst.{{ .FieldName }} = {{ .FieldType }}(val)
	}
			{{- end }}
		{{- else }}
			{{- if .IsArray }}
		dst.{{ .FieldName }}= make([]{{ .FieldType }}, len(aux.{{ .FieldName }}))
		for i, v := range aux.{{ .FieldName }} {
				dst.{{ .FieldName }}[i] = {{ .FieldType }}(v)
		}
			{{- else }}
		dst.{{ .FieldName }} = {{ .FieldType }}(aux.{{ .FieldName }})
			{{- end }}
		{{- end }}{{- end }}{{- end }}
// Code generated from ace.jar fields *.json files
// DO NOT EDIT.

{{ if .IsSetting }}
package settings
{{ else }}
package unifi
{{ end }}

import (
	"context"
	"encoding/json"
	"fmt"
	
	"github.com/ubiquiti-community/go-unifi/unifi/types"
)

// just to fix compile issues with the import.
var (
	_ context.Context
	_ fmt.Formatter
	_ json.Marshaler
	_ types.Number
)

{{ range $k, $v := .Types }}
{{- if and (eq $k $structName) ($.IsSetting) }}
{{- /* For settings, strip the "Setting" prefix from struct name */ -}}
type {{ $.CleanStructName }} struct {
	BaseSetting
	{{ range $fk, $fv := $v.Fields }}{{ if not $fv }}
	{{ else }}{{- if not (or (eq $fv.FieldName "ID") (eq $fv.FieldName "SiteID") (eq $fv.FieldName "Hidden") (eq $fv.FieldName "HiddenID") (eq $fv.FieldName "NoDelete") (eq $fv.FieldName "NoEdit") (eq $fv.FieldName "Key")) }}{{- template "field" $fv }}{{ end }}{{ end }}{{ end }}
}

func (dst *{{ $.CleanStructName }}) UnmarshalJSON(b []byte) error {
	type Alias {{ $.CleanStructName }}
	aux := &struct {
			{{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
			{{- else }}{{- if not (or (eq $fv.FieldName "ID") (eq $fv.FieldName "SiteID") (eq $fv.FieldName "Hidden") (eq $fv.FieldName "HiddenID") (eq $fv.FieldName "NoDelete") (eq $fv.FieldName "NoEdit") (eq $fv.FieldName "Key")) }}{{- template "field-customUnmarshalType" $fv }}{{ end }}{{ end }}{{- end }}

		*Alias
	}{
		Alias: (*Alias)(dst),
	}

	// First unmarshal base setting
	if err := json.Unmarshal(b, &dst.BaseSetting); err != nil {
		return fmt.Errorf("unable to unmarshal base setting: %w", err)
	}

	err := json.Unmarshal(b, &aux)
	if err != nil {
		return fmt.Errorf("unable to unmarshal alias: %w", err)
	}

		{{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
		{{- else }}{{- if not (or (eq $fv.FieldName "ID") (eq $fv.FieldName "SiteID") (eq $fv.FieldName "Hidden") (eq $fv.FieldName "HiddenID") (eq $fv.FieldName "NoDelete") (eq $fv.FieldName "NoEdit") (eq $fv.FieldName "Key")) }}{{- template "typecast" $fv }}{{ end }}{{ end }}{{ end }}

	return nil
}
{{- else }}
type {{ $k }} struct {
	{{ range $fk, $fv := $v.Fields }}{{ if not $fv }}
	{{ else }}{{- template "field" $fv }}{{ end }}{{ end }}
}

func (dst *{{ $k }}) UnmarshalJSON(b []byte) error {
	type Alias {{ $k }}
	aux := &struct {
			{{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
			{{- else }}{{- template "field-customUnmarshalType" $fv }}{{ end }}{{- end }}

		*Alias
	}{
		Alias: (*Alias)(dst),
	}

	err := json.Unmarshal(b, &aux)
	if err != nil {
		return fmt.Errorf("unable to unmarshal alias: %w", err)
	}

		{{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
		{{- else }}{{- template "typecast" $fv }}{{ end }}{{ end }}

	return nil
}
{{- end }}
{{ end }}

{{- if not .IsSetting }}
{{- if ne .StructName "BGPConfig" }}
func (c *ApiClient) list{{ .StructName }}(ctx context.Context, site string) ([]{{ .StructName }}, error) {
{{- if .IsV2 }}
	var respBody []{{ .StructName }}
{{- else }}
	var respBody struct {
		Meta meta      `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
{{- end }}

	err := c.do(
		ctx,
		"GET",
		fmt.Sprintf("{{ if .IsV2 }}v2/{{ end }}api/s{{ if .IsV2 }}ite{{ end }}/%s/{{ if eq .StructName "Device" }}stat/{{ else if not .IsV2 }}rest/{{ end }}{{ .ResourcePath }}", site),
		nil,
		&respBody,
	)
	if err != nil {
		return nil, err
	}

{{- if .IsV2 }}
	return respBody, nil
{{- else }}
	return respBody.Data, nil
{{- end }}
}
{{- end }}

func (c *ApiClient) get{{ .StructName }}(
	ctx context.Context,
	site string,
{{- if and (not .IsSetting) (ne .StructName "BGPConfig") }}
	id string,
{{- end }}
) (*{{ .StructName }}, error) {
{{- if and .IsV2 (ne .StructName "BGPConfig") }}
	respBody, err := c.list{{ .StructName }}(ctx, site)
	if err != nil {
		return nil, err
	}

	if len(respBody) == 0 {
		return nil, &NotFoundError{}
	}

	for _, val := range respBody {
		if val.ID == id {
			return &val, nil
		}
	}

	return nil, &NotFoundError{}
{{- else }}
	{{- if ne .StructName "BGPConfig" }}
	var respBody struct {
		Meta meta `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
	{{- else }}
	var respBody []{{ .StructName }}
	{{- end }}
	err := c.do(
		ctx,
		"GET",
		fmt.Sprintf("{{ if .IsV2 }}v2/{{ end }}api/s{{ if .IsV2 }}ite{{ end }}/%s/{{ if eq .StructName "Device" }}stat/{{ else if not .IsV2 }}rest/{{ end }}{{ .ResourcePath }}{{ if ne .StructName "BGPConfig" }}/%s{{ end }}", site{{ if ne .StructName "BGPConfig" }}, id{{ end }}),
		nil,
		&respBody,
	)
	if err != nil {
		return nil, err
	}

	{{- if ne .StructName "BGPConfig" }}
	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	d := respBody.Data[0]
	{{- else }}
	if len(respBody) != 1 {
		return nil, &NotFoundError{}
	}

	d := respBody[0]
	{{- end }}
	return &d, nil
{{- end }}
}

func (c *ApiClient) delete{{ .StructName }}(
	ctx context.Context,
	site string,
{{- if and (not .IsSetting) (ne .StructName "BGPConfig") }}
	id string,
{{- end }}
) error {
	err := c.do(
		ctx,
		"DELETE",
		fmt.Sprintf("{{ if .IsV2 }}v2/{{ end }}api/s{{ if .IsV2 }}ite{{ end }}/%s/{{ if eq .StructName "Device" }}stat/{{ else if not .IsV2 }}rest/{{ end }}{{ .ResourcePath }}{{ if ne .StructName "BGPConfig" }}/%s{{ end }}", site{{ if ne .StructName "BGPConfig" }}, id{{ end }}),
		struct{}{},
		nil,
	)
	if err != nil {
		return err
	}
	return nil
}

func (c *ApiClient) create{{ .StructName }}(
	ctx context.Context,
	site string,
	d *{{ .StructName }},
) (*{{ .StructName }}, error) {
{{- if .IsV2 }}
	var respBody {{ .StructName }}
{{- else }}
	var respBody struct {
		Meta meta      `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
{{- end }}

	err := c.do(
		ctx,
		"POST",
		fmt.Sprintf("{{ if .IsV2 }}v2/api/site{{ else }}api/s{{ end }}/%s/{{ if eq .StructName "Device" }}stat/{{ else if .IsV2 }}{{ else }}rest/{{ end }}{{ .ResourcePath }}", site),
		d,
		&respBody,
	)
	if err != nil {
		return nil, err
	}
{{ if .IsV2 }}
	return &respBody, nil
{{- else }}
	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	res := respBody.Data[0]

	return &res, nil
{{- end }}
}

{{ if ne .StructName "BGPConfig" }}
func (c *ApiClient) update{{ .StructName }}(
	ctx context.Context,
	site string,
	d *{{ .StructName }},
) (*{{ .StructName }}, error) {
{{- if .IsV2 }}
	var respBody {{ .StructName }}
{{- else }}
	var respBody struct {
		Meta meta      `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
{{- end }}
	err := c.do(
		ctx,
		"PUT",
		fmt.Sprintf("{{ if .IsV2 }}v2/api/site{{ else }}api/s{{ end }}/%s/{{ if .IsV2 }}{{ else }}rest/{{ end }}{{ .ResourcePath }}/%s", site, d.ID),
		d,
		&respBody,
	)
	if err != nil {
		return nil, err
	}
{{ if .IsV2 }}
	return &respBody, nil
{{- else }}
	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	res := respBody.Data[0]

	return &res, nil
{{- end }}
}
{{- end }}
{{- end }}
